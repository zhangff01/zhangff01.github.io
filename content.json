{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/08/28/hello-world/"},{"title":"JVM","text":"首先讲一下 JVM 运行时的数据区域，线程共享的区域是堆和方法区。Java的对象在堆中分配内存，因此堆是垃圾回收的主要区域，现在的垃圾回收主要采用分代回收算法，其主要思想是根据不同时期的对象采用不同的垃圾回收算法，因此堆又分为新生代和老年代，其中新生代又可以细分为eden, s0 , s1 区域，对象首先在 eden 区域分配，经过一次垃圾回收存活下来的对象年龄加一，等到一个对象的年龄达到 15(默认值) 的时候这个对象会晋升到老年代。方法区是 JVM 的一种规范，存放已被加载的类信息，常量，静态变量等数据，HotSpot 虚拟机在 JDK 1.8 之前作为永久代来实现，但是永久代的垃圾回收效率很低而且大小受 JVM 的限制，因此从 1.8 开始用元空间来实现方法区，元空间存放在本地内存中。运行时常量池是方法区的一部分，从JDK1.7 开始，JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆中开辟了一块区域存放运行时常量池。线程私有的区域是虚拟机栈，本地方法栈和程序计数器PCR，这些区域的生命周期随着线程的创建而创建，随着线程的结束而死亡。在java虚拟机规范中，虚拟机栈和本地方法栈都会出现StackOverflowError和OutofMemoryError，程序计数器是java虚拟机中唯一一块不会产生error的内存区域，StackOverflowError代表的是，当栈深度超过虚拟机分配给线程的栈大小时就会出现此error，OutofMemoryError代表的是，当再申请新的内存时，虚拟机分配给线程的内存大小中无法再分配新的内存，就会出现此error。 然后是垃圾回收的时候我们需要判断一个对象是否需要回收，比较简单的是引用计数法，对象增加一个引用就会加1，为0是被回收，但是有循环引用的缺陷，Java采用的是可达性分析算法，以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。GC Roots一般包括下面几种对象： 1.虚拟机栈和本地方法栈中引用的对象 2.方法区中类静态属性和常量引用的对象 前面说到现在的商业JVM采用分代收集算法，新生代采用复制算法，老年代采用标记清除或者标记整理算法。复制算法是指新生代划分为Eden和S0，S1区域(默认大小比例8:1:1)，GC开始时对象都在Eden，S0区域，S1区域是空的，GC进行的时候，Eden区域存活下来的对象会被复制到S1，而S0区域存活下来的对象年龄达到15的会被移到老年代，没有达到的也被复制到S1，然后交换S0和S1的角色，这样一次GC结束后，Eden和S1区域都是空的。标记整理算法和标记清理很像，只是在清除阶段会移动存活的对象到一端这样不会产生内存碎片。垃圾收集器 JVM虚拟机有2种运行模式，Client模式和Server模式，32位的JDK一般都支持server和client两种模式。64位JDK只支持Server模式。 新生代：Serial收集器（单线程，复制算法，Client模式）。ParNew收集器（多线程，Serial收集器的多线程版本）。Parallel Scavenge收集器（多线程，复制算法，吞吐量优先）。老年代：Serial Old收集器，Serial收集器的老年代版本，单线程，采用的是标记-整理算法。作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用。Parallel Old收集器，Parallel Scavenge收集器的老年代版本，多线程，采用的是标记-整理算法，是一种以获取最短回收停顿时间为目标的收集器。CMS收集器，使用的是标记-清除算法，多线程，和用户线程并发，所以会导致老年代有足够的空间但是因为不连续而无法分配对象，不得不使用Serial Old进行一次Full GC。CMS在官方介绍里面不建议使用。新生代和老年代：G1收集器，多线程和用户线程并发，可以管理新生代和老年代的收集器，会将堆划分为大小相等的区块Region，虽然也保留了新生代、老年代的概念，但新生代和老年代不再是相互隔离的，他们都是一部分Region（不需要连续）的集合。从整理来看采用标记-整理算法，从局部2个Region之间看是采用复制算法。JDK 1.8 默认使用Parallel Scavenge+Parallel Old垃圾收集器。除了 CMS 和 G1 之外，其它垃圾收集器和用户线程都是以串行的方式执行，会导致STW。Minor GC 和 Full GC的区别 新生代GC（Minor GC）：Minor GC指发生在新生代的GC，当Eden区域不够使，就会发生一次Minor GC。老年代GC（Full GC/Major GC）：Full GC指发生在老年代的GC，出现了Full GC一般会伴随着至少一次的Minor GC（老年代的对象大部分是Minor GC过程中从新生代进入老年代）。 Full GC的场景： 1.老年代空间不足。2.空间担保失败。指的是发生Minor GC的时候，JVM会先检查老年代最大可用的连续空间是否大于新生代所有对象空间，如果不大于(确保最坏情况新生代对象都转移到老年代)则会先触发Full GC。3.调用System.gc()。不建议使用这个方法，调用这个方法也只是建议GC，JVM也不一定会GC。","link":"/2018/07/28/JVM/"}],"tags":[{"name":"Java基础","slug":"Java基础","link":"/tags/Java基础/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"}],"categories":[{"name":"Java基础","slug":"Java基础","link":"/categories/Java基础/"}]}